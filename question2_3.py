# -*- coding: utf-8 -*-
"""Question2&3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18wrm75XL5E6e4hS8NEcxPHS3cLQ6AK4e
"""

from abc import ABC, abstractmethod
from datetime import datetime, timedelta
from itertools import filterfalse

"""**Question 2**"""

# A

class Item(ABC):
    _loanDuration = 14

    def getLoanDuration(self):
        return Item._loanDuration

    def setLoanDuration(self,newDuration):
        Item._loanDuration = newDuration

    def __init__(self,title,yearPublished,cost):
        self._title = title
        self._yearPublished = yearPublished
        self._cost = cost

    def get_title(self):
        return self._title

    def get_yearPublished(self):
        return self._yearPublished

    def get_cost(self):
        return self._cost

    @abstractmethod
    def getFinesPerDay(self):
        pass

    @abstractmethod
    def getAdminCharge(self):
        pass

    def lostCharges(self):
        return self.getAdminCharge() + self.get_cost()

    def __str__(self):
        return self._title+" "+str(self._yearPublished) +" Cost: $"+str(self._cost)

# B

class Book(Item):

    def __init__(self, title,yearPublished,cost,authors):
        super().__init__(title,yearPublished,cost)
        self._authors = authors

    def getAdminCharge(self):
        
        if (datetime.now().year - self._yearPublished) >= 10:
            return self._cost + 10/self._cost
        else:
            return  self._cost + ((10 - (int(datetime.now().year )-self._yearPublished))/10)/self._cost

    def getFinesPerDay(self):
        return 0.25

    def __str__(self):
        return self._title+" "+str(self._yearPublished)+" Cost: $"+str(self._cost)+" By "+", ".join(self._authors)


class Media(Item):  
    _loanDuration = 3

    def getAdminCharge(self):
        return 1.5*self._cost

    def getFinesPerDay(self):
        return 2.50

# C

class ItemCopy:
    _nextId = 1
    def __init__(self,item,loanDate):
        self._item = item
        self._copyId = ItemCopy._nextId
        ItemCopy._nextId += 1
        self._available = True

    def get_item(self):
        return self._item
    
    def get_copyId(self):
        return self._copyId

    def get_available(self):
        return self._available

    def set_available(self,status):
        self._available = status

    def __str__(self):
        return "CopyId: "+str(self._copyId)+" "+self._item.__str__()+" Available: "+str(self._available)

# D

class Loan:
    def __init__(self,itemCopy,loanDate):
        self._itemCopy = itemCopy
        self._dueDate = loanDate + timedelta(days=self._itemCopy._item.getLoanDuration())
        self._returnDate = None
        self._itemCopy._available = False

    def  get_dueDate(self):
        return self._dueDate
    
    def get_returnDate(self):
        return self._returnDate

    def set_returnDate(self,returnDate):
        self._returnDate = returnDate
        self._itemCopy._available = True

    def renew(self,renewDate):
        newDate = renewDate + timedelta(days=self._itemCopy._item.getLoanDuration())
        if newDate > self._dueDate:
            self._dueDate = newDate
            return True
        return False

    def getFines(self):
        finePerDay = self._itemCopy._item.getFinesPerDay()
        if self._returnDate == None and (self._dueDate >= self._returnDate):
            return -1

        dateDiffrence = self._returnDate - self._dueDate
        return finePerDay*dateDiffrence.days

    def __str__(self):
        if self._returnDate:  loan = self._returnDate.strftime("%d %b %Y")
        else: loan = "On Loan"

        return "Loan Copy id: " + str(self._itemCopy._copyId) +" "+ self._itemCopy._item._title + "\n \t Due date: " + self._dueDate.strftime("%d %b %Y") + " Return on: " + loan

"""**Question3**"""

# A i

class LibraryException(Exception):
    pass

# A ii

class LibraryPaymentException(LibraryException):

    def __init__(self,amount):
        self._amount = _amount

    def get_amount(self):
        return self._amount

# B i

class Member:
    _loanQuota = 4

    def getLoanQuota(cls):
        return cls._loanQuota

    def __init__(self,memberId, name):
        self._memberId = memberId
        self._name = name
        self._amountOwed = 0
        self._loans = []

    def get_memberId(self):
        return self._memberId
    
    def get_amountOwed(self):
        return self._amountOwed

    def pastLoans(self,title=None):
        reponse = []
        if title:
            for loan in self._loans:
                if loan._returnDate and loan._itemCopy._item._title == title: reponse.append(loan)
        else:
            for loan in self._loans:
                if loan._returnDate: reponse.append(loan)
        return reponse

    def presentLoans(self,title=None):
        reponse = []
        if title:
            for loan in self._loans:
                if loan._returnDate != None and loan._itemCopy._item._title == title: reponse.append(loan)
        else:
            for loan in self._loans:
                if loan._returnDate != None: reponse.append(loan)
        return reponse

    def countCurrentLoan(self):
        count = 0
        for loan in self._loans:
            if loan._returnDate == None: count += 1
        return count

    def quotaReached(self):
        if self.countCurrentLoan() == Member._loanQuota:
            return True
        else:
            return False

    def searchLoanFor(self,title):
        titleloans = []
        for loan in self._loans:
            if loan._itemCopy._item._title == title:
                if loan._returnDate == None:
                    return loan
                titleloans.append(loan)

        # if titleloans == []:
        #     return None
        
        # latestLoan = titleloans[0];
        # for loan in titleloans:
        #     if loan._returnDate > latestLoan._returnDate:
        #         latestLoan = loan
                        
        # return latestLoan
            
        return titleloans[-1] # latest

    def borrowItem(self,copyItem,dateBorrowed):

        if copyItem._available == False:
            raise LibraryException(copyItem.__str__()+" Item Unavailable")

        if self.quotaReached():
            raise LibraryException("the loan quota has been reached.")

        if self._amountOwed != 0:
            raise LibraryException("The amount owed: "+str(self._amountOwed)+" member needs to pay an outstanding fine first")
        
        loan = Loan(copyItem,dateBorrowed)
        self._loans.append(loan)

        return True

    def renew(self,title,renewDate):

        titleloans = []
        for loan in self._loans:
            if loan._itemCopy._item._title == title:
                titleloans.append(loan)

        if titleloans == []:
            raise LibraryException("There is no loan recorded for the title "+title)
        
        currentTitleLoans = []
        for loan in titleloans:
            if loan._returnDate == None:
                 currentTitleLoans.append(loan)
        
        if currentTitleLoans == []:
            raise LibraryException("Item has been returned on "+titleloans[-1]._returnDate.strftime("%d %b %Y"))
        
        unpassedLoans = []
        for loan in currentTitleLoans:
            if renewDate < loan._dueDate:
                unpassedLoans.append(loan)

        if unpassedLoans == []:
            raise LibraryException("item due date is: "+currentTitleLoans[-1]._dueDate.strftime("%d %b %Y")+" renewDate is "+renewDate.strftime("%d %b %Y"))

        unpassedLoans[-1]._dueDate = renewDate
        return True

    def returnItem(self,title,returnDate):
        titleloans = []
        for loan in self._loans:
            if loan._itemCopy._item._title == title:
                titleloans.append(loan)

        if titleloans == []:
            raise LibraryException("There is no loan recorded for "+title)

        currentTitleLoans = []
        for loan in titleloans:
            if loan._returnDate == None:
                 currentTitleLoans.append(loan)
        
        if currentTitleLoans == []:
            raise LibraryException("Item has been returned on "+titleloans[-1]._returnDate.strftime("%d %b %Y"))
        
        currentTitleLoans[-1]._returnDate = returnDate

        self._amountOwed+=currentTitleLoans[-1].getFines()
        currentTitleLoans[-1]._itemCopy._available = True
        return True

    def pay(self,amount):
        if amount <= 0: raise LibraryException("You owed $"+str(self._amountOwed)++" Please pay an amount that is more than $0")
        
        if self._amountOwed == 0: return 0

        self._amountOwed -= amount
        if self._amountOwed < 0:
            self._amountOwed = 0
        return self._amountOwed

    def loanStr(self,loans=None):
        if loans==None:
            return [loan.__str__()+"\n" for loan in self._loans]

        return [loan.__str__()+"\n" for loan in loans]

    def __str__(self):

        past_loans = "No past loan"
        present_loans = "No outstanding loan"

        passedLoans = []
        presentLoans = []
        for loan in self._loans:
            if loan._returnDate:
                passedLoans.append(loan.__str__()+"\n")
            else:
                presentLoans.append(loan.__str__()+"\n")

        if passedLoans != []: past_loans = passedLoans 
        if presentLoans != []: present_loans = presentLoans 

        outstanding_loans = len(present_loans)

        return "Id: "+str(self._memberId)+" "+str(self._name)+" Owed: $"+str(self._amountOwed)+"\nPast Loans:\n"+"".join(past_loans)+"\nPresent Loans:\n"+"".join(present_loans)+"\nOutstanding loans: "+str(outstanding_loans)

# B ii

class JuniorMember(Member):
    _loanQuota = 2

# C 

class Library:
    def __init__(self):
        self._members = {}
        self._items = {}
        self._copyItems = []

    def addItem(self,item):
        try:
            self._items[item._title]
        except:
            self._items.update({item._title:item})
            return True
        else:
            return False

    def addCopyItem(self,item):
        self._copyItems.append(ItemCopy(item,datetime.now()))

    
    def registerMember(self,member):
        try:
            self._members[member._memberId]
        except:
            self._members.update({member._memberId:member})
            return True
        else:
            return False

    def removeMember(self,memberId):
        try:            
            return self._members.pop(member._memberId)
        except: None

    def searchMember(self,memberId):
        try:
            return self._members[member._memberId]
        except:
            return None

    def searchCopyItem(self,copyId):
        for copyItem in self._copyItems:
            if copyItem._copyId == copyId:
                return copyItem
        return None

    def getAvailableCopyItems(self):
        result = []
        for item in self._copyItems:
            if item._available == True:
                result.append(item)
        return result

    def copyItemStr(self,copyItemList=None):
        if copyItemList:
            return [item.__str__()+"\n" for item in copyItemList]
        return [item.__str__()+"\n" for item in self._copyItems]

    def memberStr(self):
        return [member.__str__()+"\n" for member in self._members.values()]

    def __str__(self):
        return "Items\n"+"\n".join([item.__str__()+"\n" for item in self._items.values()])+"\nCopy Items\n"+"".join([item.__str__()+"\n" for item in self._copyItems])+"\nMembers\n"+"\n".join(self.memberStr())

# D

## creating members 
member1 = Member("S123","John")
member2 = Member("J111","Mary")

library = Library()
## add items
item1 = Book("The Road to Forget",2020,35.0,["Justin Grave", "Tom Aplesson"])
item2 = Media("Asia Food And Culture",2019,30.0)
item4 = Media("Dark Knight",2019,29.0)
item3 = Media("Powerpoint Presentation Tips",2020,15.0)
library.addItem(item1)
library.addItem(item2)
library.addItem(item3)
library.addItem(item4)

## add members
library.registerMember(member1)
library.registerMember(member2)

## add copyitem
library.addCopyItem(item1)
library.addCopyItem(item1)
library.addCopyItem(item2)
library.addCopyItem(item2)
library.addCopyItem(item2)
library.addCopyItem(item3)
library.addCopyItem(item3)
library.addCopyItem(item4)
library.addCopyItem(item4)

# JOHN HAD 4 LOANS
member1.borrowItem(library._copyItems[0],datetime.strptime("28/2/2021", '%d/%m/%Y'))
member1.borrowItem(library._copyItems[2],datetime.strptime("28/2/2021", '%d/%m/%Y'))
member1.borrowItem(library._copyItems[5],datetime.strptime("28/2/2021", '%d/%m/%Y'))
member1.borrowItem(library._copyItems[7],datetime.strptime("10/3/2021", '%d/%m/%Y'))

# MARY HAD 1 LOAN
member2.borrowItem(library._copyItems[8],datetime.strptime("24/2/2021", '%d/%m/%Y'))

member1.returnItem("Dark Knight",datetime.strptime("17/3/2021", '%d/%m/%Y'))

member2.renew("Dark Knight",datetime.strptime("9/3/2021", '%d/%m/%Y'))

member1.pay(6.5)

member1.borrowItem(library._copyItems[7],datetime.strptime("22/3/2021", '%d/%m/%Y'))

member2.returnItem("Dark Knight",datetime.strptime("17/3/2021", '%d/%m/%Y'))

print(library.__str__())

# E

running=True
while running == True:
    print("""Menu
    1. Borrow Item
    2. Renew Item
    3. Return Item
    4. Pay Outstanding Balance
    0. Exit""")
    option = input("\nEnter option: ")
    try:
        option = int(option)
        if option > 4 or option < 0:
            raise Exception("Invalid option")
    except Exception as e:
        print("Invalid option")

    try:
        # OPTION 0 EXIT
        if option==0:
            running=False
            print("Program ends")
            break
        # OPTION 2 BORROW ITEM
        elif option==1:
            try:
                id = input("Enter member ID: ")
                member = library._members[id]
                print("Current number of loans: "+str(member.countCurrentLoan())+" Quota: "+str(member.getLoanQuota()))

            except Exception as e:
                print(e)
                print("invalid member ID")
                raise LibraryException

            if member.quotaReached():
                print("Quota reached. No more loan allowed")

            while running == True:
                try:
                    date = input("date borrow in dd/mm/yyyy: ")
                    date = datetime.strptime(date, '%d/%m/%Y')
                    break
                except:
                    print(date," is not in the format dd/mm/yyyy \n")
                
            while not member.quotaReached():

                print("\nAvailable Items\n")
                for item in library.getAvailableCopyItems():
                    print(item.__str__())
                copyID = input("Enter the copy id or 0 to end: ")

                if copyID == "0": break

                copyItem = library.searchCopyItem(int(copyID))
                print(copyItem.__str__())
                outstanding = member.get_amountOwed()

                if outstanding > 0:
                    yesOrNo = input("You have $"+str(outstanding)+" outstanding fines. Do you wish to pay your fines now? (y/n): ")
                    yesOrNo = yesOrNo.lower()

                    if yesOrNo == "y" or yesOrNo == "yes":

                        amount_left = member.pay(member.get_amountOwed())

                        member.borrowItem(copyItem,date)
                        print("Successfully borrowed ",copyItem._item._title)
                    elif yesOrNo == "n" or yesOrNo == "no":
                        print("Please pay your fines first before borrowing")                      
                        break

                else:
                    member.borrowItem(copyItem,date)
                
                if member.getLoanQuota() == member.countCurrentLoan():
                    print("Loan quota reached")

            print(member.__str__())

        # OPTION 2 RENEW ITEM
        elif option==2:
            try:
                id = input("Enter member ID: ")
                member = library._members[id]

            except Exception:
                print("invalid member ID")
                raise LibraryException

            title = input("Enter title: ")
            while running == True:
                try:
                    date = input("date borrow in dd/mm/yyyy: ")
                    date = datetime.strptime(date, '%d/%m/%Y')
                    break
                except:
                    print(date," is not in the format dd/mm/yyyy \n")

            try:
                member.renew(title,date)
            except Exception as e:
                print(e)
            else:
                print("Successfully renewed ",title)

            print(member.__str__())

        # OPTION 3 RETURN ITEM
        elif option==3:

            try:
                id = input("Enter member ID: ")
                member = library._members[id]
            except Exception:
                print("invalid member ID")
                raise LibraryException

            while running == True:
                try:
                    date = input("Enter return date in dd/mm/yyyy: ")
                    date = datetime.strptime(date, '%d/%m/%Y')
                    break
                except:
                    print(date," is not in the format dd/mm/yyyy \n")

            while running == True:
                if member.presentLoans() == []:
                    print("No more outstanding loan")
                    break

                title = input("Enter title or <ENTER> to end: ")

                if title == "": break

                try: member.returnItem(title,date)
                except Exception as e: print(e)
                else: print("Successfully returned",title)

            print(member.__str__())

        # OPTION 4 PAY BALANCE
        elif option==4:
            try:
                id = input("Enter member ID: ")
                member = library._members[id]
            except Exception:
                print("invalid member ID")
                raise LibraryException


            if member.get_amountOwed() == 0: 
                print("There is no outstanding fines")

            else:
                while running == True:
                    amount = input("Enter amount: ")
                    try: amonut = int(amount)
                    except Exception as e: print(amonut,"is not a valid amount")
                    else:
                        try: leftAmount = member.pay(amonut)
                        except LibraryException as e: print(e)
                        else:
                            print("Successfully paid "+str(amount)+". Current balance: ",member.get_amountOwed())
                            if leftAmount == 0:
                                print("Your change: $",amonut-leftAmount)
                        break

            print(member.__str__())

    except Exception as e: print(e)

